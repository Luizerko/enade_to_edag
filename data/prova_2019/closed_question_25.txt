questão 25
a linguagem python não permite alguns tipos de otimização como, por exemplo, a recursão em cauda e, 
devido à sua natureza dinâmica, é impossível realizar esse tipo de otimização em tempo de compilação 
tal como em linguagens funcionais como haskell ou ml.
disponível em: <http:/www.python-history.blogspot.com/2009/04/origins-of-pythons-functional-features.html>.  
acesso: em 15 jun. 2019 (adaptado).
o trecho de código a seguir, escrito em python, realiza a busca binária de um elemento x em uma lista 
lst e a função binary_search tem código recursivo em cauda.
1 def binary_search(x, lst, low=none, high=none): 
2 	
if low == none : low = 0 
3 	
if high == none : high = len(lst)-1 
4 	
mid = low + (high - low) // 2 
5 	
if low > high : 
6 	
	
return none 
7 	
elif lst[mid] == x : 
8 	
	
return mid 
9 	
elif lst[mid] > x : 
10 	
	
return binary_search(x, lst, low, mid-1) 
11 	
else : 
12 	
	
return binary_search(x, lst, mid+1, high)
disponível em: <https://www.kylem.net/programming/tailcall.html>. acesso em: 15 jun. 2019 (adaptado).
considerando esse trecho de código, avalie as afirmações a seguir.
i.	 substituindo-se o conteúdo da linha 10 por high = mid - 1 e substituindo-se o conteúdo da 
linha 12 por low = mid + 1, não se altera o resultado de uma busca.
ii.	 envolvendo-se o código das linhas 4 a 12 em um laço while true, substituindo-se o conteúdo 
da linha 10 por high = mid - 1 e substituindo-se o conteúdo da linha 12 por low = mid + 1 
remove-se a recursão de cauda e o resultado da busca não é alterado.
iii.	 substituindo-se o código da linha 10 por:
newhigh = mid-1
return binary_search(x, lst, low, newhigh) 
e substituindo-se o código da linha 12 por: 
newlow = mid+1
return binary_search(x, lst, newlow, high)
remove-se a recursão de cauda.
iv.	 substituindo-se o conteúdo das linhas 9 a 12 por 
if lst[mid] > x : 
newlow = low 
newhigh = mid-1 
else: 
newlow = mid+1 
newhigh = high 
return binary_search(x, lst, newlow, newhigh) 
mantém-se o resultado da busca.
é correto o que se afirma em
a	 i, apenas.
b	 ii e iii, apenas.
c	 ii e iv, apenas.
d	 i, iii e iv, apenas.
e	 i, ii, iii e iv.
*r09201929*

engenharia de computação
30